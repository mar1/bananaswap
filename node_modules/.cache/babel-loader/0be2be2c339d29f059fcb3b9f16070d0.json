{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import{Contract}from'@ethersproject/contracts';import{namehash}from'ethers/lib/utils';var REGISTRAR_ABI=[{constant:true,inputs:[{name:'node',type:'bytes32'}],name:'resolver',outputs:[{name:'resolverAddress',type:'address'}],payable:false,stateMutability:'view',type:'function'}];var REGISTRAR_ADDRESS='0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e';var RESOLVER_ABI=[{constant:true,inputs:[{internalType:'bytes32',name:'node',type:'bytes32'}],name:'contenthash',outputs:[{internalType:'bytes',name:'',type:'bytes'}],payable:false,stateMutability:'view',type:'function'}];// cache the resolver contracts since most of them are the public resolver\nfunction resolverContract(resolverAddress,provider){return new Contract(resolverAddress,RESOLVER_ABI,provider);}/**\r\n * Fetches and decodes the result of an ENS contenthash lookup on mainnet to a URI\r\n * @param ensName to resolve\r\n * @param provider provider to use to fetch the data\r\n */export default function resolveENSContentHash(_x,_x2){return _resolveENSContentHash.apply(this,arguments);}function _resolveENSContentHash(){_resolveENSContentHash=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(ensName,provider){var ensRegistrarContract,hash,resolverAddress;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:ensRegistrarContract=new Contract(REGISTRAR_ADDRESS,REGISTRAR_ABI,provider);hash=namehash(ensName);_context.next=4;return ensRegistrarContract.resolver(hash);case 4:resolverAddress=_context.sent;return _context.abrupt(\"return\",resolverContract(resolverAddress,provider).contenthash(hash));case 6:case\"end\":return _context.stop();}}},_callee);}));return _resolveENSContentHash.apply(this,arguments);}","map":{"version":3,"sources":["C:/Users/marin/Desktop/bananaswap/src/utils/resolveENSContentHash.ts"],"names":["Contract","namehash","REGISTRAR_ABI","constant","inputs","name","type","outputs","payable","stateMutability","REGISTRAR_ADDRESS","RESOLVER_ABI","internalType","resolverContract","resolverAddress","provider","resolveENSContentHash","ensName","ensRegistrarContract","hash","resolver","contenthash"],"mappings":"+TAAA,OAASA,QAAT,KAAyB,0BAAzB,CAEA,OAASC,QAAT,KAAyB,kBAAzB,CAEA,GAAMC,CAAAA,aAAa,CAAG,CACpB,CACEC,QAAQ,CAAE,IADZ,CAEEC,MAAM,CAAE,CACN,CACEC,IAAI,CAAE,MADR,CAEEC,IAAI,CAAE,SAFR,CADM,CAFV,CAQED,IAAI,CAAE,UARR,CASEE,OAAO,CAAE,CACP,CACEF,IAAI,CAAE,iBADR,CAEEC,IAAI,CAAE,SAFR,CADO,CATX,CAeEE,OAAO,CAAE,KAfX,CAgBEC,eAAe,CAAE,MAhBnB,CAiBEH,IAAI,CAAE,UAjBR,CADoB,CAAtB,CAqBA,GAAMI,CAAAA,iBAAiB,CAAG,4CAA1B,CAEA,GAAMC,CAAAA,YAAY,CAAG,CACnB,CACER,QAAQ,CAAE,IADZ,CAEEC,MAAM,CAAE,CACN,CACEQ,YAAY,CAAE,SADhB,CAEEP,IAAI,CAAE,MAFR,CAGEC,IAAI,CAAE,SAHR,CADM,CAFV,CASED,IAAI,CAAE,aATR,CAUEE,OAAO,CAAE,CACP,CACEK,YAAY,CAAE,OADhB,CAEEP,IAAI,CAAE,EAFR,CAGEC,IAAI,CAAE,OAHR,CADO,CAVX,CAiBEE,OAAO,CAAE,KAjBX,CAkBEC,eAAe,CAAE,MAlBnB,CAmBEH,IAAI,CAAE,UAnBR,CADmB,CAArB,CAwBA;AACA,QAASO,CAAAA,gBAAT,CAA0BC,eAA1B,CAAmDC,QAAnD,CAAiF,CAC/E,MAAO,IAAIf,CAAAA,QAAJ,CAAac,eAAb,CAA8BH,YAA9B,CAA4CI,QAA5C,CAAP,CACD,CAED;AACA;AACA;AACA;AACA,GACA,uBAA8BC,CAAAA,qBAA9B,8D,iHAAe,iBAAqCC,OAArC,CAAsDF,QAAtD,gKACPG,oBADO,CACgB,GAAIlB,CAAAA,QAAJ,CAAaU,iBAAb,CAAgCR,aAAhC,CAA+Ca,QAA/C,CADhB,CAEPI,IAFO,CAEAlB,QAAQ,CAACgB,OAAD,CAFR,uBAGiBC,CAAAA,oBAAoB,CAACE,QAArB,CAA8BD,IAA9B,CAHjB,QAGPL,eAHO,+CAIND,gBAAgB,CAACC,eAAD,CAAkBC,QAAlB,CAAhB,CAA4CM,WAA5C,CAAwDF,IAAxD,CAJM,wD","sourcesContent":["import { Contract } from '@ethersproject/contracts'\r\nimport { Provider } from '@ethersproject/abstract-provider'\r\nimport { namehash } from 'ethers/lib/utils'\r\n\r\nconst REGISTRAR_ABI = [\r\n  {\r\n    constant: true,\r\n    inputs: [\r\n      {\r\n        name: 'node',\r\n        type: 'bytes32'\r\n      }\r\n    ],\r\n    name: 'resolver',\r\n    outputs: [\r\n      {\r\n        name: 'resolverAddress',\r\n        type: 'address'\r\n      }\r\n    ],\r\n    payable: false,\r\n    stateMutability: 'view',\r\n    type: 'function'\r\n  }\r\n]\r\nconst REGISTRAR_ADDRESS = '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\r\n\r\nconst RESOLVER_ABI = [\r\n  {\r\n    constant: true,\r\n    inputs: [\r\n      {\r\n        internalType: 'bytes32',\r\n        name: 'node',\r\n        type: 'bytes32'\r\n      }\r\n    ],\r\n    name: 'contenthash',\r\n    outputs: [\r\n      {\r\n        internalType: 'bytes',\r\n        name: '',\r\n        type: 'bytes'\r\n      }\r\n    ],\r\n    payable: false,\r\n    stateMutability: 'view',\r\n    type: 'function'\r\n  }\r\n]\r\n\r\n// cache the resolver contracts since most of them are the public resolver\r\nfunction resolverContract(resolverAddress: string, provider: Provider): Contract {\r\n  return new Contract(resolverAddress, RESOLVER_ABI, provider)\r\n}\r\n\r\n/**\r\n * Fetches and decodes the result of an ENS contenthash lookup on mainnet to a URI\r\n * @param ensName to resolve\r\n * @param provider provider to use to fetch the data\r\n */\r\nexport default async function resolveENSContentHash(ensName: string, provider: Provider): Promise<string> {\r\n  const ensRegistrarContract = new Contract(REGISTRAR_ADDRESS, REGISTRAR_ABI, provider)\r\n  const hash = namehash(ensName)\r\n  const resolverAddress = await ensRegistrarContract.resolver(hash)\r\n  return resolverContract(resolverAddress, provider).contenthash(hash)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}