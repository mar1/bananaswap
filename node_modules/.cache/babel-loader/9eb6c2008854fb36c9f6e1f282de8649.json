{"ast":null,"code":"import { currencyEquals, DEV, WDEV } from 'moonbeamswap';\nimport { useMemo } from 'react';\nimport { tryParseAmount } from '../state/swap/hooks';\nimport { useTransactionAdder } from '../state/transactions/hooks';\nimport { useCurrencyBalance } from '../state/wallet/hooks';\nimport { useActiveWeb3React } from './index';\nimport { useWDEVContract } from './useContract';\nexport let WrapType;\n\n(function (WrapType) {\n  WrapType[WrapType[\"NOT_APPLICABLE\"] = 0] = \"NOT_APPLICABLE\";\n  WrapType[WrapType[\"WRAP\"] = 1] = \"WRAP\";\n  WrapType[WrapType[\"UNWRAP\"] = 2] = \"UNWRAP\";\n})(WrapType || (WrapType = {}));\n\nconst NOT_APPLICABLE = {\n  wrapType: WrapType.NOT_APPLICABLE\n};\n/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */\n\nexport default function useWrapCallback(inputCurrency, outputCurrency, typedValue) {\n  const {\n    chainId,\n    account\n  } = useActiveWeb3React();\n  const wethContract = useWDEVContract();\n  const balance = useCurrencyBalance(account !== null && account !== void 0 ? account : undefined, inputCurrency); // we can always parse the amount typed as the input currency, since wrapping is 1:1\n\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue]);\n  const addTransaction = useTransactionAdder();\n  return useMemo(() => {\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE;\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount);\n\n    if (inputCurrency === DEV && currencyEquals(WDEV[chainId], outputCurrency)) {\n      return {\n        wrapType: WrapType.WRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.deposit({\n              value: `0x${inputAmount.raw.toString(16)}`\n            });\n            addTransaction(txReceipt, {\n              summary: `Wrap ${inputAmount.toSignificant(6)} DEV to WDEV`\n            });\n          } catch (error) {\n            console.error('Could not deposit', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient DEV balance'\n      };\n    } else if (currencyEquals(WDEV[chainId], inputCurrency) && outputCurrency === DEV) {\n      return {\n        wrapType: WrapType.UNWRAP,\n        execute: sufficientBalance && inputAmount ? async () => {\n          try {\n            const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`);\n            addTransaction(txReceipt, {\n              summary: `Unwrap ${inputAmount.toSignificant(6)} WDEV to ETH`\n            });\n          } catch (error) {\n            console.error('Could not withdraw', error);\n          }\n        } : undefined,\n        inputError: sufficientBalance ? undefined : 'Insufficient WDEV balance'\n      };\n    } else {\n      return NOT_APPLICABLE;\n    }\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction]);\n}","map":{"version":3,"sources":["C:/Users/marin/Documents/Dev/bananaswap/moonbeam-uniswap/uniswap-interface-moonbeam/src/hooks/useWrapCallback.ts"],"names":["currencyEquals","DEV","WDEV","useMemo","tryParseAmount","useTransactionAdder","useCurrencyBalance","useActiveWeb3React","useWDEVContract","WrapType","NOT_APPLICABLE","wrapType","useWrapCallback","inputCurrency","outputCurrency","typedValue","chainId","account","wethContract","balance","undefined","inputAmount","addTransaction","sufficientBalance","lessThan","WRAP","execute","txReceipt","deposit","value","raw","toString","summary","toSignificant","error","console","inputError","UNWRAP","withdraw"],"mappings":"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","sourcesContent":["import { Currency, currencyEquals, DEV, WDEV } from 'moonbeamswap'\r\nimport { useMemo } from 'react'\r\nimport { tryParseAmount } from '../state/swap/hooks'\r\nimport { useTransactionAdder } from '../state/transactions/hooks'\r\nimport { useCurrencyBalance } from '../state/wallet/hooks'\r\nimport { useActiveWeb3React } from './index'\r\nimport { useWDEVContract } from './useContract'\r\n\r\nexport enum WrapType {\r\n  NOT_APPLICABLE,\r\n  WRAP,\r\n  UNWRAP\r\n}\r\n\r\nconst NOT_APPLICABLE = { wrapType: WrapType.NOT_APPLICABLE }\r\n/**\r\n * Given the selected input and output currency, return a wrap callback\r\n * @param inputCurrency the selected input currency\r\n * @param outputCurrency the selected output currency\r\n * @param typedValue the user input value\r\n */\r\nexport default function useWrapCallback(\r\n  inputCurrency: Currency | undefined,\r\n  outputCurrency: Currency | undefined,\r\n  typedValue: string | undefined\r\n): { wrapType: WrapType; execute?: undefined | (() => Promise<void>); inputError?: string } {\r\n  const { chainId, account } = useActiveWeb3React()\r\n  const wethContract = useWDEVContract()\r\n  const balance = useCurrencyBalance(account ?? undefined, inputCurrency)\r\n  // we can always parse the amount typed as the input currency, since wrapping is 1:1\r\n  const inputAmount = useMemo(() => tryParseAmount(typedValue, inputCurrency), [inputCurrency, typedValue])\r\n  const addTransaction = useTransactionAdder()\r\n\r\n  return useMemo(() => {\r\n    if (!wethContract || !chainId || !inputCurrency || !outputCurrency) return NOT_APPLICABLE\r\n\r\n    const sufficientBalance = inputAmount && balance && !balance.lessThan(inputAmount)\r\n\r\n    if (inputCurrency === DEV && currencyEquals(WDEV[chainId], outputCurrency)) {\r\n      return {\r\n        wrapType: WrapType.WRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.deposit({ value: `0x${inputAmount.raw.toString(16)}` })\r\n                  addTransaction(txReceipt, { summary: `Wrap ${inputAmount.toSignificant(6)} DEV to WDEV` })\r\n                } catch (error) {\r\n                  console.error('Could not deposit', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient DEV balance'\r\n      }\r\n    } else if (currencyEquals(WDEV[chainId], inputCurrency) && outputCurrency === DEV) {\r\n      return {\r\n        wrapType: WrapType.UNWRAP,\r\n        execute:\r\n          sufficientBalance && inputAmount\r\n            ? async () => {\r\n                try {\r\n                  const txReceipt = await wethContract.withdraw(`0x${inputAmount.raw.toString(16)}`)\r\n                  addTransaction(txReceipt, { summary: `Unwrap ${inputAmount.toSignificant(6)} WDEV to ETH` })\r\n                } catch (error) {\r\n                  console.error('Could not withdraw', error)\r\n                }\r\n              }\r\n            : undefined,\r\n        inputError: sufficientBalance ? undefined : 'Insufficient WDEV balance'\r\n      }\r\n    } else {\r\n      return NOT_APPLICABLE\r\n    }\r\n  }, [wethContract, chainId, inputCurrency, outputCurrency, inputAmount, balance, addTransaction])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}