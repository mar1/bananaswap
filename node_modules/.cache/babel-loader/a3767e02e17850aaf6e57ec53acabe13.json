{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";import _asyncToGenerator from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";import _classCallCheck from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";import _inherits from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";import _createSuper from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";import _wrapNativeSuper from\"C:\\\\Users\\\\marin\\\\Desktop\\\\bananaswap\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/wrapNativeSuper\";function wait(ms){return new Promise(function(resolve){return setTimeout(resolve,ms);});}function waitRandom(min,max){return wait(min+Math.round(Math.random()*Math.max(0,max-min)));}/**\r\n * This error is thrown if the function is cancelled before completing\r\n */export var CancelledError=/*#__PURE__*/function(_Error){_inherits(CancelledError,_Error);var _super=_createSuper(CancelledError);function CancelledError(){_classCallCheck(this,CancelledError);return _super.call(this,'Cancelled');}return CancelledError;}(/*#__PURE__*/_wrapNativeSuper(Error));/**\r\n * Throw this error if the function should retry\r\n */export var RetryableError=/*#__PURE__*/function(_Error2){_inherits(RetryableError,_Error2);var _super2=_createSuper(RetryableError);function RetryableError(){_classCallCheck(this,RetryableError);return _super2.apply(this,arguments);}return RetryableError;}(/*#__PURE__*/_wrapNativeSuper(Error));/**\r\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\r\n * @param fn function to retry\r\n * @param n how many times to retry\r\n * @param minWait min wait between retries in ms\r\n * @param maxWait max wait between retries in ms\r\n */export function retry(fn,_ref){var n=_ref.n,minWait=_ref.minWait,maxWait=_ref.maxWait;var completed=false;var rejectCancelled;var promise=new Promise(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve,reject){var result;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:rejectCancelled=reject;case 1:if(!true){_context.next=24;break;}result=void 0;_context.prev=3;_context.next=6;return fn();case 6:result=_context.sent;if(!completed){resolve(result);completed=true;}return _context.abrupt(\"break\",24);case 11:_context.prev=11;_context.t0=_context[\"catch\"](3);if(!completed){_context.next=15;break;}return _context.abrupt(\"break\",24);case 15:if(!(n<=0||!(_context.t0 instanceof RetryableError))){_context.next=19;break;}reject(_context.t0);completed=true;return _context.abrupt(\"break\",24);case 19:n--;case 20:_context.next=22;return waitRandom(minWait,maxWait);case 22:_context.next=1;break;case 24:case\"end\":return _context.stop();}}},_callee,null,[[3,11]]);}));return function(_x,_x2){return _ref2.apply(this,arguments);};}());return{promise:promise,cancel:function cancel(){if(completed)return;completed=true;rejectCancelled(new CancelledError());}};}","map":{"version":3,"sources":["C:/Users/marin/Desktop/bananaswap/src/utils/retry.ts"],"names":["wait","ms","Promise","resolve","setTimeout","waitRandom","min","max","Math","round","random","CancelledError","Error","RetryableError","retry","fn","n","minWait","maxWait","completed","rejectCancelled","promise","reject","result","cancel"],"mappings":"27BAAA,QAASA,CAAAA,IAAT,CAAcC,EAAd,CAAyC,CACvC,MAAO,IAAIC,CAAAA,OAAJ,CAAY,SAAAC,OAAO,QAAIC,CAAAA,UAAU,CAACD,OAAD,CAAUF,EAAV,CAAd,EAAnB,CAAP,CACD,CAED,QAASI,CAAAA,UAAT,CAAoBC,GAApB,CAAiCC,GAAjC,CAA6D,CAC3D,MAAOP,CAAAA,IAAI,CAACM,GAAG,CAAGE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,GAAgBF,IAAI,CAACD,GAAL,CAAS,CAAT,CAAYA,GAAG,CAAGD,GAAlB,CAA3B,CAAP,CAAX,CACD,CAED;AACA;AACA,GACA,UAAaK,CAAAA,cAAb,wGACE,yBAAc,8DACN,WADM,EAEb,CAHH,sDAAoCC,KAApC,GAMA;AACA;AACA,GACA,UAAaC,CAAAA,cAAb,sQAAoCD,KAApC,GAEA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASE,CAAAA,KAAT,CACLC,EADK,MAGwC,IAD3CC,CAAAA,CAC2C,MAD3CA,CAC2C,CADxCC,OACwC,MADxCA,OACwC,CAD/BC,OAC+B,MAD/BA,OAC+B,CAC7C,GAAIC,CAAAA,SAAS,CAAG,KAAhB,CACA,GAAIC,CAAAA,eAAJ,CACA,GAAMC,CAAAA,OAAO,CAAG,GAAInB,CAAAA,OAAJ,2FAAe,iBAAOC,OAAP,CAAgBmB,MAAhB,6HAC7BF,eAAe,CAAGE,MAAlB,CAD6B,WAEtB,IAFsB,0BAGvBC,MAHuB,8CAKVR,CAAAA,EAAE,EALQ,QAKzBQ,MALyB,eAMzB,GAAI,CAACJ,SAAL,CAAgB,CACdhB,OAAO,CAACoB,MAAD,CAAP,CACAJ,SAAS,CAAG,IAAZ,CACD,CATwB,iGAYrBA,SAZqB,0EAerBH,CAAC,EAAI,CAAL,EAAU,EAAE,sBAAiBH,CAAAA,cAAnB,CAfW,2BAgBvBS,MAAM,aAAN,CACAH,SAAS,CAAG,IAAZ,CAjBuB,2CAoBzBH,CAAC,GApBwB,+BAsBrBX,CAAAA,UAAU,CAACY,OAAD,CAAUC,OAAV,CAtBW,oGAAf,oEAAhB,CAyBA,MAAO,CACLG,OAAO,CAAPA,OADK,CAELG,MAAM,CAAE,iBAAM,CACZ,GAAIL,SAAJ,CAAe,OACfA,SAAS,CAAG,IAAZ,CACAC,eAAe,CAAC,GAAIT,CAAAA,cAAJ,EAAD,CAAf,CACD,CANI,CAAP,CAQD","sourcesContent":["function wait(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\nfunction waitRandom(min: number, max: number): Promise<void> {\r\n  return wait(min + Math.round(Math.random() * Math.max(0, max - min)))\r\n}\r\n\r\n/**\r\n * This error is thrown if the function is cancelled before completing\r\n */\r\nexport class CancelledError extends Error {\r\n  constructor() {\r\n    super('Cancelled')\r\n  }\r\n}\r\n\r\n/**\r\n * Throw this error if the function should retry\r\n */\r\nexport class RetryableError extends Error {}\r\n\r\n/**\r\n * Retries the function that returns the promise until the promise successfully resolves up to n retries\r\n * @param fn function to retry\r\n * @param n how many times to retry\r\n * @param minWait min wait between retries in ms\r\n * @param maxWait max wait between retries in ms\r\n */\r\nexport function retry<T>(\r\n  fn: () => Promise<T>,\r\n  { n, minWait, maxWait }: { n: number; minWait: number; maxWait: number }\r\n): { promise: Promise<T>; cancel: () => void } {\r\n  let completed = false\r\n  let rejectCancelled: (error: Error) => void\r\n  const promise = new Promise<T>(async (resolve, reject) => {\r\n    rejectCancelled = reject\r\n    while (true) {\r\n      let result: T\r\n      try {\r\n        result = await fn()\r\n        if (!completed) {\r\n          resolve(result)\r\n          completed = true\r\n        }\r\n        break\r\n      } catch (error) {\r\n        if (completed) {\r\n          break\r\n        }\r\n        if (n <= 0 || !(error instanceof RetryableError)) {\r\n          reject(error)\r\n          completed = true\r\n          break\r\n        }\r\n        n--\r\n      }\r\n      await waitRandom(minWait, maxWait)\r\n    }\r\n  })\r\n  return {\r\n    promise,\r\n    cancel: () => {\r\n      if (completed) return\r\n      completed = true\r\n      rejectCancelled(new CancelledError())\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}